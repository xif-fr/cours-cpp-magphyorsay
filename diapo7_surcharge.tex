\documentclass[c]{beamer}
\usepackage{org-preamble}
\usepackage[cpp_teaching]{slide-style}
\usetheme{default}
\newcommand{\inline}[1]{\mintinline[breaklines]{c++}{#1}}


\title{Surcharge d'opérateur}

\begin{document}

\maketitle

\begin{frame}[fragile,label={sec:orgheadline1}]{Surcharge d'opérateur}
 \begin{itemize}
\item \Cpp permet de \structure{surdéfinir les opérateurs} tels que \texttt{+}, \texttt{=}, \texttt{+=}, \texttt{++},
\texttt{<<}, \texttt{new}\ldots{}

\item Fondamentalement, l'appel à un opérateur est identique à l'appel d'une
fonction \structure{\(\rightarrow\) possibilité de surdéfinir}

\item Le but est de définir ces ``fonctions'' pour des classes dépourvues de ces opérateurs. On voudrait pouvoir faire
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
Vecteur2D vec1(2, 3);
Vecteur2D vec2(4, 5);
my_vec1 += my_vec2;
Vecteur2D vec3 = (vec1 - vec2) * 0.7;
...
\end{minted}

\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exemple de surcharge de l'opérateur unaire \texttt{+=}}

\begin{onlyenv}<1>
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Déclaration
class Vecteur2D {
private:
  double m_x;
  double m_y;
public:
  Vecteur2D (const double x_, const double y_);

};
\end{minted}
\end{onlyenv}
\begin{onlyenv}<2>
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Déclaration
class Vecteur2D {
private:
  double m_x;
  double m_y;
public:
  Vecteur2D (const double x_, const double y_);
  void operator+= (const Vecteur2D& right);
};
\end{minted}
\end{onlyenv}
\pause
\vspace{1em}
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Définition
void Vecteur2D::operator+= (const Vecteur2D& right) {
  m_x += right.m_x;
  m_y += right.m_y;
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline6}]{Exemple de surcharge de l'opérateur unaire \texttt{+=}}
 \begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Définition
void Vecteur2D::operator+= (const Vecteur2D& right) {
  m_x += right.m_x;
  m_y += right.m_y;
}

// Utilisation
void main () {
  Vecteur2D my_vec1(2, 3);
  Vecteur2D my_vec2(4, 5);
  my_vec1 += my_vec2;
}
\end{minted}

\begin{cbox}
\begin{center}
\structure{\(\rightarrow\) équivalent à l'usage d'une méthode \texttt{ajoute} s'utilisant de la façon
 suivante \inline{my_vec1.ajoute(my_vec2);}}
\end{center}
\end{cbox}
\end{frame}

\begin{frame}[fragile]{Opérateurs unaires}
Pratique usuelle avec les opérations unaires : renvoyer le résultat de l'opération.\\

\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Déclaration
class Vecteur2D {
  ...
  Vecteur2D& operator+= (const Vecteur2D& right);
};

// Définition
Vecteur2D& Vecteur2D::operator+= (const Vecteur2D& right) {
  m_x += right.m_x;
  m_y += right.m_y;
  return *this;
}
\end{minted}

\begin{cbox}
\begin{center}
\structure{\(\rightarrow\) utilisation du pointeur \texttt{this} qui retourne l'adresse de l'objet courant}
\end{center}
\end{cbox}

\end{frame}

%-------------------------------------------------------------------

\begin{frame}[fragile,label={sec:orgheadline7}]{Surcharge de l'opérateur binaire \texttt{+} : Fonction amie}
Objectif :
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
Vecteur2D my_vec1(2, 3);
Vecteur2D my_vec2(4, 5);
Vecteur2D my_vec3 = my_vec1 + my_vec2;
\end{minted}
\pause
\vspace{1em}
Implémentation :
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Déclaration
class Vecteur2D {
  ...
  friend Vecteur2D operator+ (const Vecteur2D& left, const Vecteur2D& right);
};

// Définition
Vecteur2D operator+ (const Vecteur2D& left, const Vecteur2D& right) {
  return Vecteur2D(left.m_x + right.m_x, left.m_y + right.m_y);
}
\end{minted}
\end{frame}

%----------------------------------------------

\begin{frame}[fragile]{Surcharge de l'opérateur binaire \texttt{+} : Méthode}
Objectif :
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
Vecteur2D my_vec1(2, 3);
Vecteur2D my_vec2(4, 5);
Vecteur2D my_vec3 = my_vec1 + my_vec2;
\end{minted}
\vspace{1em}
Implémentation :
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Déclaration
class Vecteur2D {
  ...
  Vecteur2D operator+ (const Vecteur2D& right) const;
};

// Définition
Vecteur2D Vecteur2D::operator+ (const Vecteur2D& right) const {
  return Vecteur2D(m_x + right.m_x, m_y + right.m_y);
}
\end{minted}
\end{frame}

%--------------------------------------------------

\begin{frame}[fragile]{Accès d'un élément de matrice}

On peut remplacer
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
class Matrice {
public:
  ...
  double& accès (int row, int col);  // Accès à un élément de la matrice
};

double& Matrice::accès (int row, int col) {
  if (row < 0 or row >= rows or col < 0 or col >= cols)
    throw std::out_of_range();
  return data[ row*cols + col ]; // renvoie une référence
}

mat1.accès(1, 2) = 4.2;  // modification via référence
\end{minted}

\end{frame}

\begin{frame}[fragile]{Accès d'un élément de matrice}

Par
\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
class Matrice {
public:
  ...
  double& operator[] (int row, int col);  // Accès à un élément de la matrice
};

double& Matrice::operator[] (int row, int col) {
  if (row < 0 or row >= rows or col < 0 or col >= cols)
    throw std::out_of_range();
  return data[ row*cols + col ]; // renvoie une référence
}

mat1[1,2] = 4.2;  // modification via référence
\end{minted}

\end{frame}

%------------------------------------------------------------------

\begin{frame}[plain,label={sec:orgheadline12}]{}
\partpage
\end{frame}

\begin{frame}[label={sec:orgheadline13}]{Fonctions et classes amies}
\begin{itemize}
\item Du fait du principe d'encapsulation des données, les fonctions extérieures à
la classe n'ont pas accès aux membres privées de cette classe\ldots{}

\item \ldots{} à l'exception des fonctions amies

\item Utilité : quasi nulle sauf pour quelques opérations (dont la surcharge
d'opérateur)
\end{itemize}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline14}]{Exemple de fonction amie d'une classe}
 \begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
// Déclaration avec friend
class particule
{
  friend void stupid_thing(particule & particule_);
  ...
};
...
// Définition
void stupid_thing(particule & particule_)
{
  particule_.m_mass = 0.511;
}
...
// Utilisation
int main()
{
  particule my_muon(105.6, -1.6e-19);
  stupid_thing(my_muon);
}
\end{minted}
\end{frame}

\begin{frame}[fragile,label={sec:orgheadline15}]{Classe amie d'une autre classe}
 \begin{itemize}
\item Méthode d'une classe \texttt{B}, amie d'une autre classe \texttt{A}

\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
class A
{
  ...
  friend void B::methode_de_B(A & A_);
  ...
};
\end{minted}

\item Classe \texttt{B} amie d'une autre classe \texttt{A}

\begin{minted}[fontsize=\footnotesize,samepage,mathescape,xrightmargin=0.5cm,xleftmargin=0.5cm]{c++}
class A
{
  ...
  friend class B;
  ...
};
\end{minted}
\end{itemize}
\end{frame}

\end{document}
